package com.sendMail.mail.service

import com.itextpdf.text.*
import com.itextpdf.text.List
import com.itextpdf.text.pdf.BaseFont
import com.itextpdf.text.pdf.PdfPCell
import com.itextpdf.text.pdf.PdfPTable
import com.itextpdf.text.pdf.PdfWriter
import com.sendMail.mail.domain.Brevo
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.pdmodel.PDPage
import org.apache.pdfbox.pdmodel.PDPageContentStream
import org.apache.pdfbox.pdmodel.font.PDType1Font
import org.apache.pdfbox.pdmodel.font.Standard14Fonts
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import java.io.FileOutputStream
import java.nio.file.Files
import java.nio.file.Paths
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.listOf
import kotlin.collections.mapOf


@Service
class GeneratePdfService {
    private val FILE = "C:/PdfBox/angebot.pdf"

    private val url = "https://api.sendinblue.com/v3/smtp/email"

    @Value("\${BREVO_KEY}")
    private lateinit var apiKey: String

    @Value("\${TEMPLATE_ID}")
    private lateinit var templateId: String


    var baseFont: Font = FontFactory.getFont(
        "../kotlin/com/sendMail/mail/fonts/gilroy-regular.ttf",
        BaseFont.IDENTITY_H, BaseFont.EMBEDDED, 18F, Font.NORMAL, BaseColor.BLACK
    )

    var regularBaseFont: Font = FontFactory.getFont(
        "../kotlin/com/sendMail/mail/fonts/gilroy-regular.ttf",
        BaseFont.IDENTITY_H, BaseFont.EMBEDDED, 12F, Font.NORMAL, BaseColor.BLACK
    )


    private val catFont: Font = Font(
        Font.FontFamily.TIMES_ROMAN, 18F,
        Font.BOLD
    )
    private val redFont: Font = Font(
        Font.FontFamily.TIMES_ROMAN, 12F,
        Font.NORMAL, BaseColor.RED
    )
    private val subFont: Font = Font(
        Font.FontFamily.TIMES_ROMAN, 16F,
        Font.BOLD
    )
    private val smallBold: Font = Font(
        Font.FontFamily.TIMES_ROMAN, 12F,
        Font.BOLD
    )
    fun withItext(brevo: Brevo,token:String):Boolean{
        var success= false
        try {
            val document = Document()
            PdfWriter.getInstance(document, FileOutputStream(FILE))
            document.open()
            addMetaData(document,brevo)
            addTitlePage(document,brevo)
            //addContent(document,brevo)
            document.close()

           val pdf = encodePdf()

           success =  sendPdfToBrevo(pdf!!,token,brevo)



        } catch (e: Exception) {
            e.printStackTrace()
        }

        return success
    }

    private fun sendPdfToBrevo(pdf: String,token: String,brevo: Brevo) :Boolean{
        val webClient = WebClient.create()

        val requestMailBody = mapOf(
            "templateId" to templateId.toInt(),
            "params" to mapOf(
                "workingprice" to brevo.workingprice,
                "baseprice" to brevo.baseprice,
                "token" to token
            ),
            "to" to listOf(
                mapOf(
                    "email" to "benjamin.koubik@homee.de"
                )
            ),
            "attachment" to  listOf(
                mapOf(
                    "content" to pdf,
                    "name" to "angebot.pdf"
                )
            )
        )


        webClient.post()
            .uri(url)
            .header("api-key", apiKey)
            .bodyValue(requestMailBody)
            .retrieve()
            .bodyToMono(String::class.java)
            .subscribe { response -> println("Response: $response") }

        return true
    }

    private fun encodePdf(): String? {
        val inFileBytes = Files.readAllBytes(Paths.get(FILE))
        val encoded = Base64.getEncoder().encodeToString(inFileBytes)

        return encoded
    }


    private fun addMetaData(document: Document,brevo: Brevo) {
        document.addTitle("Individuelles Angebot")
        document.addSubject("erstellt fuer ${brevo.name}")
        document.addKeywords("stromee, angebot")
        document.addAuthor("stromee GmbH")
        document.addCreator("Benjamin Koubik")
    }


    @Throws(DocumentException::class)
    private fun addTitlePage(document: Document,brevo: Brevo) {
        val preface = Paragraph()
        // We add one empty line
        addEmptyLine(preface, 1)
        // Lets write a big header
        preface.add(Paragraph("Guten Tag ${brevo.anrede} ${brevo.name}", baseFont))

        addEmptyLine(preface, 1)
        // Will create: Report generated by: _name, _date
        preface.add(
            Paragraph(
                "Anbei erhalten Sie ihr individuelles Angebot vom ${SimpleDateFormat("dd.MM.yyyy").format(Date())}",
                regularBaseFont
            )
        )
        addEmptyLine(preface, 3)
        preface.add(
            Paragraph(
                "Arbeitspreis: ${brevo.workingprice}",
                regularBaseFont
            )
        )
        addEmptyLine(preface, 3)
        preface.add(
            Paragraph(
                "Grundpreis: ${brevo.baseprice}",
                regularBaseFont
            )
        )

        document.add(preface)
        // Start a new page
        document.newPage()
    }


    @Throws(DocumentException::class)
    private fun addContent(document: Document,brevo: Brevo) {
        var anchor = Anchor("First Chapter", catFont)
        anchor.name = "First Chapter"

        // Second parameter is the number of the chapter
        var catPart = Chapter(Paragraph(anchor), 1)

        var subPara = Paragraph("Subcategory 1", subFont)
        var subCatPart = catPart.addSection(subPara)
        subCatPart.add(Paragraph("Hello"))

        subPara = Paragraph("Subcategory 2", subFont)
        subCatPart = catPart.addSection(subPara)
        subCatPart.add(Paragraph("Paragraph 1"))
        subCatPart.add(Paragraph("Paragraph 2"))
        subCatPart.add(Paragraph("Paragraph 3"))

        // add a list
        createList(subCatPart)
        val paragraph = Paragraph()
        addEmptyLine(paragraph, 5)
        subCatPart.add(paragraph)

        // add a table
        createTable(subCatPart)

        // now add all this to the document
        document.add(catPart)

        // Next section
        anchor = Anchor("Second Chapter", catFont)
        anchor.name = "Second Chapter"

        // Second parameter is the number of the chapter
        catPart = Chapter(Paragraph(anchor), 1)

        subPara = Paragraph("Subcategory", subFont)
        subCatPart = catPart.addSection(subPara)
        subCatPart.add(Paragraph("This is a very important message"))

        // now add all this to the document
        document.add(catPart)
    }

    @Throws(BadElementException::class)
    private fun createTable(subCatPart: Section) {
        val table = PdfPTable(3)

        // t.setBorderColor(BaseColor.GRAY);
        // t.setPadding(4);
        // t.setSpacing(4);
        // t.setBorderWidth(1);
        var c1 = PdfPCell(Phrase("Table Header 1"))
        c1.horizontalAlignment = Element.ALIGN_CENTER
        table.addCell(c1)

        c1 = PdfPCell(Phrase("Table Header 2"))
        c1.horizontalAlignment = Element.ALIGN_CENTER
        table.addCell(c1)

        c1 = PdfPCell(Phrase("Table Header 3"))
        c1.horizontalAlignment = Element.ALIGN_CENTER
        table.addCell(c1)
        table.headerRows = 1

        table.addCell("1.0")
        table.addCell("1.1")
        table.addCell("1.2")
        table.addCell("2.1")
        table.addCell("2.2")
        table.addCell("2.3")

        subCatPart.add(table)
    }

    private fun createList(subCatPart: Section) {
        val list = List(true, false, 10F)
        list.add(ListItem("First point"))
        list.add(ListItem("Second point"))
        list.add(ListItem("Third point"))
        subCatPart.add(list)
    }

    private fun addEmptyLine(paragraph: Paragraph, number: Int) {
        for (i in 0 until number) {
            paragraph.add(Paragraph(" "))
        }
    }



    fun generatePDF(brevo: Brevo,token:String):ByteArray{


        val document = PDDocument()
        val offerPage = PDPage()
        document.addPage(offerPage);

        val contentStream = PDPageContentStream(document, offerPage)

        contentStream.beginText()


        contentStream.newLineAtOffset(25f, 700f)

        val anrede = "Guten Tag ${brevo.anrede} ${brevo.name}"

        contentStream.setFont( PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD), 12F);

        contentStream.showText(anrede)




        contentStream.newLineAtOffset(25f, 680f)

        val erstelltAm = SimpleDateFormat("dd.MM.yyyy").format(Date())

        contentStream.setFont( PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD), 12F);

        contentStream.showText(erstelltAm)


        contentStream.newLineAtOffset(25f, 650f)

        val angebot = "Arbeitspreis: 22"

        contentStream.setFont( PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD), 12F);

        contentStream.showText(angebot)



        contentStream.endText()

        println("Content added")


        contentStream.close()


        document.save("C:/PdfBox/angebot.pdf");

        document.close()




        val inFileBytes = Files.readAllBytes(Paths.get("C:/PdfBox/angebot.pdf"))
        val encoded = Base64.getEncoder().encodeToString(inFileBytes)
        val pdfData = Files.readAllBytes(Paths.get("C:/PdfBox/angebot.pdf"))


        val webClient = WebClient.create() // With empty URI


        val requestMailBody = mapOf(
            "templateId" to templateId.toInt(),
            "params" to mapOf(
                "workingprice" to "666",
                "baseprice" to "",
                "token" to token
            ),
            "to" to listOf(
                mapOf(
                    "email" to "benjamin.koubik@homee.de"
                )
            ),
            "attachment" to  listOf(
                mapOf(
                    "content" to encoded,
                    "name" to "angebot.pdf"
                )
            )
        )


        webClient.post()
            .uri(url)
            .header("api-key", apiKey)
            .bodyValue(requestMailBody)
            .retrieve()
            .bodyToMono(String::class.java)
            .subscribe { response -> println("Response: $response") }


        return pdfData

    }
}